<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Neon 2048 Fusion</title>
<script src="https://sdk.crazygames.com/crazygames-sdk-v3.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;user-select:none}
html,body{width:100%;height:100%;overflow:hidden;background:#050515;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif}
#gameCanvas{display:block;position:absolute;top:0;left:0}
#bannerContainer{position:fixed;bottom:0;left:50%;transform:translateX(-50%);width:320px;height:50px;z-index:1000;background:#050510;display:flex;justify-content:center;align-items:center}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="bannerContainer"></div>
<script>
"use strict";

/* ===== AUDIO ===== */
const SFX = {
  ctx: null, muted: false, vol: 0.25,
  init() { try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} },
  resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
  tone(freq, dur, type, vol, ramp) {
    if (this.muted || !this.ctx) return;
    try {
      const n = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.connect(g); g.connect(this.ctx.destination);
      o.type = type || 'sine';
      o.frequency.setValueAtTime(freq, n);
      if (ramp) o.frequency.linearRampToValueAtTime(ramp, n + dur);
      g.gain.setValueAtTime((vol || 1) * this.vol, n);
      g.gain.linearRampToValueAtTime(0, n + dur);
      o.start(n); o.stop(n + dur);
    } catch(e) {}
  },
  play(t) {
    if (this.muted || !this.ctx) return;
    switch(t) {
      case 'swipe': this.tone(300, 0.1, 'sine', 0.3, 500); break;
      case 'merge': this.tone(440, 0.15, 'triangle', 0.4, 880); break;
      case 'bigmerge': this.tone(523, 0.25, 'triangle', 0.5, 1047); setTimeout(() => this.tone(659, 0.2, 'sine', 0.3, 1319), 50); break;
      case 'spawn': this.tone(600, 0.08, 'sine', 0.15, 400); break;
      case 'click': this.tone(800, 0.04, 'square', 0.15); break;
      case 'win': [523,659,784,1047].forEach((f,i) => setTimeout(() => this.tone(f, 0.3, 'triangle', 0.4), i * 150)); break;
      case 'lose': [400,300,200].forEach((f,i) => setTimeout(() => this.tone(f, 0.25, 'sawtooth', 0.25), i * 200)); break;
      case 'powerup': this.tone(400, 0.25, 'sine', 0.35, 1200); break;
      case 'coin': this.tone(1200, 0.06, 'sine', 0.25); setTimeout(() => this.tone(1600, 0.08, 'sine', 0.2), 50); break;
      case 'star': this.tone(800, 0.15, 'sine', 0.3, 1600); break;
    }
  }
};

/* ===== SDK ===== */
const BANNER_H = 50;
let sdk = null, sdkReady = false, gpActive = false, bannerDone = false;

async function initSDK() {
  try {
    if (window.CrazyGames && window.CrazyGames.SDK) {
      sdk = window.CrazyGames.SDK; await sdk.init(); sdkReady = true; requestBanner();
    }
  } catch(e) {}
}

function requestBanner() {
  if (!sdkReady || bannerDone) return;
  try { sdk.banner.requestBanner({ id: 'bannerContainer', width: 320, height: 50 }); bannerDone = true; } catch(e) {}
}

function gpStart() { if (!sdkReady || gpActive) return; try { sdk.game.gameplayStart(); gpActive = true; } catch(e) {} }
function gpStop() { if (!sdkReady || !gpActive) return; try { sdk.game.gameplayStop(); gpActive = false; } catch(e) {} }
function happytime() { if (sdkReady) try { sdk.game.happytime(); } catch(e) {} }

let lastAdTime = 0, adBusy = false, gamePaused = false;
const AD_INTERVAL = 60000;

async function tryMidAd() {
  if (!sdkReady || adBusy || Date.now() - lastAdTime < AD_INTERVAL) return;
  adBusy = true; gamePaused = true; pauseTimer(); gpStop();
  try { await sdk.ad.requestAd('midgame'); } catch(e) {}
  lastAdTime = Date.now(); adBusy = false; gamePaused = false; resumeTimer();
  if (gameState === 'playing') gpStart();
}

async function rewardAd(ok) {
  if (adBusy) return;
  if (!sdkReady) { if (ok) ok(); return; }
  adBusy = true; gamePaused = true; pauseTimer(); gpStop();
  try { await sdk.ad.requestAd('rewarded'); adBusy = false; gamePaused = false; resumeTimer(); if (gameState === 'playing') gpStart(); if (ok) ok(); }
  catch(e) { adBusy = false; gamePaused = false; resumeTimer(); if (gameState === 'playing') gpStart(); }
}

let timerPauseAt = 0, timerPaused = 0;
function pauseTimer() { if (MODES[curMode].timed && !timerPauseAt) timerPauseAt = Date.now(); }
function resumeTimer() { if (timerPauseAt) { timerPaused += Date.now() - timerPauseAt; timerPauseAt = 0; } }

initSDK();

/* ===== CANVAS ===== */
const CV = document.getElementById('gameCanvas');
const CTX = CV.getContext('2d');
let W, H, S; // width, height, scale
let CS, PAD, GX, GY, GTOTAL, RAD; // cell size, padding, grid x/y, grid total, corner radius

/* ===== STATE ===== */
let grid = [], prevGrid = [], prevScore = 0;
let score = 0, best = 0, coins = 0, stars = 0;
let gameState = 'menu'; // menu, playing, shop, leaderboard, achievements, gameover, win, tutorial
let contWin = false, revives = 0, savedMode = -1;
const MAX_REV = 2;
let combo = 0, maxCombo = 0, totalMerges = 0;
let powers = { undo: 1, hint: 1, swap: 0, destroy: 0, x2: 0 };
let x2Active = false;
let swapMode = false, swapFirst = null, destroyMode = false;

// Animations
let animTiles = [], isAnim = false, animT = 0;
let newTiles = [], newT = 0;
let mergeTiles2 = [];
let swapAnim = false, swapT = 0, sw1 = null, sw2 = null;
let hintDir = null, hintT = 0;
let particles = [], floats = [];

// Timer mode
let timerStart = 0, timeLeft = 0;

// Daily
let dailyStreak = 0, lastDaily = '';

// Leaderboard & achievements
let lb = [];
let unlocked = [];
let achPopup = null, achPopupT = 0;

// Rate
let rateShown = false, rateTimer = 0, showRate = false;

// Touch
let touchX = 0, touchY = 0;
let btns = [];

/* ===== MODES ===== */
let curMode = 0;
const MODES = [
  { name: 'Classic 4x4', grid: 4, target: 2048 },
  { name: 'Big 5x5', grid: 5, target: 2048 },
  { name: 'Mega 6x6', grid: 6, target: 4096 },
  { name: 'Speed 4x4', grid: 4, target: 2048, timed: true, time: 180 },
  { name: 'Zen 4x4', grid: 4, target: 2048, zen: true }
];

const SHOP_ITEMS = [
  { id: 'undo', name: 'Undo', cost: 50, desc: '+1 free undo' },
  { id: 'hint', name: 'Hint', cost: 30, desc: '+1 free hint' },
  { id: 'swap', name: 'Swap', cost: 80, desc: '+1 tile swap' },
  { id: 'destroy', name: 'Destroy', cost: 100, desc: 'Remove a tile' },
  { id: 'x2', name: 'Score x2', cost: 120, desc: 'Double next merge' },
];

const ACHS = [
  { id: 'merge1', name: 'First Fusion', desc: 'Make your first merge', fn: () => totalMerges >= 1 },
  { id: 'combo3', name: 'Triple Combo', desc: 'Get 3x combo', fn: () => maxCombo >= 3 },
  { id: 't256', name: 'Rising', desc: 'Create 256 tile', fn: () => maxTile() >= 256 },
  { id: 't1024', name: 'Almost There', desc: 'Create 1024 tile', fn: () => maxTile() >= 1024 },
  { id: 't2048', name: 'Champion', desc: 'Create 2048 tile', fn: () => maxTile() >= 2048 },
  { id: 'c500', name: 'Rich', desc: 'Have 500 coins', fn: () => coins >= 500 },
  { id: 'd7', name: 'Dedicated', desc: '7 day streak', fn: () => dailyStreak >= 7 },
  { id: 's5k', name: 'High Score', desc: 'Score 5000+', fn: () => score >= 5000 },
];

const TILE_COLORS = {
  2:    { bg: '#0f1640', bd: '#3355ff', tx: '#99aaff', gl: '#3355ff' },
  4:    { bg: '#0f2040', bd: '#3399ff', tx: '#88ccff', gl: '#3399ff' },
  8:    { bg: '#0f3030', bd: '#33ddaa', tx: '#88ffdd', gl: '#33ddaa' },
  16:   { bg: '#203010', bd: '#88dd33', tx: '#ccff88', gl: '#88dd33' },
  32:   { bg: '#302510', bd: '#dd8833', tx: '#ffcc88', gl: '#dd8833' },
  64:   { bg: '#301010', bd: '#dd3333', tx: '#ff8888', gl: '#dd3333' },
  128:  { bg: '#301025', bd: '#dd33aa', tx: '#ff88dd', gl: '#dd33aa' },
  256:  { bg: '#201030', bd: '#9933dd', tx: '#cc88ff', gl: '#9933dd' },
  512:  { bg: '#101040', bd: '#5555ff', tx: '#aaaaff', gl: '#5555ff' },
  1024: { bg: '#103040', bd: '#33bbdd', tx: '#88eeff', gl: '#33bbdd' },
  2048: { bg: '#052525', bd: '#00dddd', tx: '#88ffff', gl: '#00dddd' },
  4096: { bg: '#250525', bd: '#dd00dd', tx: '#ff88ff', gl: '#dd00dd' },
  8192: { bg: '#252505', bd: '#dddd00', tx: '#ffff88', gl: '#dddd00' },
};

function tileColor(v) { return TILE_COLORS[v] || { bg: '#222', bd: '#888', tx: '#ccc', gl: '#888' }; }
function maxTile() { let m = 0; for (let r of grid) for (let v of r) if (v > m) m = v; return m; }
function cloneGrid(g) { return g.map(r => [...r]); }

/* ===== LAYOUT ===== */
function resize() {
  W = window.innerWidth;
  H = window.innerHeight - BANNER_H;
  CV.width = W; CV.height = H;
  S = Math.min(W / 400, H / 700);
  recalcGrid();
}

function recalcGrid() {
  const gn = MODES[curMode] ? MODES[curMode].grid : 4;
  PAD = Math.round(8 * S);
  const margin = Math.round(20 * S);
  const maxW = W - margin * 2;
  const maxH = H * 0.42;
  const cellW = (maxW - (gn + 1) * PAD) / gn;
  const cellH = (maxH - (gn + 1) * PAD) / gn;
  CS = Math.floor(Math.min(cellW, cellH));
  CS = Math.max(CS, 20);
  GTOTAL = CS * gn + PAD * (gn + 1);
  GX = Math.round((W - GTOTAL) / 2);
  GY = Math.round(H * 0.28);
  RAD = Math.round(8 * S);
}

/* ===== DRAWING PRIMITIVES ===== */
function roundRect(x, y, w, h, r) {
  CTX.beginPath();
  CTX.moveTo(x + r, y);
  CTX.lineTo(x + w - r, y);
  CTX.quadraticCurveTo(x + w, y, x + w, y + r);
  CTX.lineTo(x + w, y + h - r);
  CTX.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  CTX.lineTo(x + r, y + h);
  CTX.quadraticCurveTo(x, y + h, x, y + h - r);
  CTX.lineTo(x, y + r);
  CTX.quadraticCurveTo(x, y, x + r, y);
  CTX.closePath();
}

function drawBox(x, y, w, h, r, fill, stroke, lw, glowCol, glowAmt) {
  CTX.save();
  if (glowCol) { CTX.shadowColor = glowCol; CTX.shadowBlur = glowAmt || 8; }
  roundRect(x, y, w, h, r);
  if (fill) { CTX.fillStyle = fill; CTX.fill(); }
  CTX.shadowBlur = 0; CTX.shadowColor = 'transparent';
  if (stroke) { CTX.strokeStyle = stroke; CTX.lineWidth = lw || 2; CTX.stroke(); }
  CTX.restore();
}

function drawText(text, x, y, size, color, glow, align, baseline) {
  CTX.save();
  CTX.font = `bold ${Math.round(size)}px 'Segoe UI', Arial, sans-serif`;
  CTX.textAlign = align || 'center';
  CTX.textBaseline = baseline || 'middle';
  if (glow) { CTX.shadowColor = glow; CTX.shadowBlur = 8 * S; }
  CTX.fillStyle = color;
  CTX.fillText(text, x, y);
  CTX.restore();
}

function fitSize(text, maxW, startSize) {
  let sz = startSize;
  CTX.font = `bold ${Math.round(sz)}px 'Segoe UI', Arial, sans-serif`;
  while (CTX.measureText(text).width > maxW && sz > 6) {
    sz -= 0.5;
    CTX.font = `bold ${Math.round(sz)}px 'Segoe UI', Arial, sans-serif`;
  }
  return sz;
}

/* ===== BUTTON ===== */
function drawButton(x, y, w, h, text, color, active, badge) {
  const glow = active ? 16 * S : 8 * S;
  drawBox(x, y, w, h, RAD, '#0a0a2088', color, 2 * S, color, glow);
  const fs = fitSize(text, w * 0.88, Math.min(h * 0.42, 18 * S));
  drawText(text, x + w / 2, y + h / 2, fs, color, color);
  if (badge !== undefined && badge > 0) {
    const br = Math.min(w, h) * 0.16;
    const bx = x + w - br * 0.4, by = y + br * 0.4;
    CTX.save();
    CTX.fillStyle = '#ee3333'; CTX.shadowColor = '#ee3333'; CTX.shadowBlur = 4 * S;
    CTX.beginPath(); CTX.arc(bx, by, br, 0, Math.PI * 2); CTX.fill();
    CTX.shadowBlur = 0;
    drawText(badge.toString(), bx, by, br * 1.1, '#fff');
    CTX.restore();
  }
}

function drawButtonDim(x, y, w, h, text) {
  drawBox(x, y, w, h, RAD, '#0a0a2088', '#2a2a44', 2 * S, '#1a1a33', 3 * S);
  const fs = fitSize(text, w * 0.88, Math.min(h * 0.42, 18 * S));
  drawText(text, x + w / 2, y + h / 2, fs, '#3a3a55', '#1a1a33');
}

function drawIconButton(x, y, w, h, text, color, active, iconFn, badge) {
  const glow = active ? 16 * S : 8 * S;
  drawBox(x, y, w, h, RAD, '#0a0a2088', color, 2 * S, color, glow);
  if (iconFn) iconFn(x + w / 2, y + h * 0.36, Math.min(w, h) * 0.3, color);
  const fs = fitSize(text, w * 0.9, Math.min(h * 0.22, 13 * S));
  drawText(text, x + w / 2, y + h * 0.78, fs, color, color);
  if (badge !== undefined && badge > 0) {
    const br = Math.min(w, h) * 0.14;
    const bx = x + w - br * 0.3, by = y + br * 0.3;
    CTX.save();
    CTX.fillStyle = '#ee3333'; CTX.shadowColor = '#ee3333'; CTX.shadowBlur = 4 * S;
    CTX.beginPath(); CTX.arc(bx, by, br, 0, Math.PI * 2); CTX.fill();
    CTX.shadowBlur = 0;
    drawText(badge.toString(), bx, by, br * 1.1, '#fff');
    CTX.restore();
  }
}

/* ===== ICONS ===== */
function iconUndo(cx, cy, sz, col) {
  CTX.save(); CTX.strokeStyle = col; CTX.lineWidth = 2.5 * S; CTX.lineCap = 'round';
  CTX.beginPath(); CTX.arc(cx, cy, sz * 0.4, 0.4, Math.PI * 1.8); CTX.stroke();
  const ax = cx + sz * 0.4 * Math.cos(0.4), ay = cy + sz * 0.4 * Math.sin(0.4);
  CTX.beginPath(); CTX.moveTo(ax - sz * 0.2, ay); CTX.lineTo(ax, ay); CTX.lineTo(ax, ay - sz * 0.2); CTX.stroke();
  CTX.restore();
}
function iconHint(cx, cy, sz, col) {
  CTX.save(); CTX.strokeStyle = col; CTX.lineWidth = 2.5 * S; CTX.lineCap = 'round';
  CTX.beginPath(); CTX.arc(cx, cy - sz * 0.1, sz * 0.25, Math.PI * 1.1, Math.PI * 1.9);
  CTX.lineTo(cx + sz * 0.12, cy + sz * 0.18); CTX.lineTo(cx - sz * 0.12, cy + sz * 0.18); CTX.closePath(); CTX.stroke();
  CTX.beginPath(); CTX.moveTo(cx - sz * 0.1, cy + sz * 0.26); CTX.lineTo(cx + sz * 0.1, cy + sz * 0.26); CTX.stroke();
  CTX.restore();
}
function iconSwap(cx, cy, sz, col) {
  CTX.save(); CTX.strokeStyle = col; CTX.lineWidth = 2.5 * S; CTX.lineCap = 'round';
  CTX.beginPath(); CTX.moveTo(cx - sz * 0.35, cy - sz * 0.12); CTX.lineTo(cx + sz * 0.35, cy - sz * 0.12);
  CTX.moveTo(cx + sz * 0.15, cy - sz * 0.3); CTX.lineTo(cx + sz * 0.35, cy - sz * 0.12); CTX.lineTo(cx + sz * 0.15, cy + sz * 0.06); CTX.stroke();
  CTX.beginPath(); CTX.moveTo(cx + sz * 0.35, cy + sz * 0.12); CTX.lineTo(cx - sz * 0.35, cy + sz * 0.12);
  CTX.moveTo(cx - sz * 0.15, cy - sz * 0.06); CTX.lineTo(cx - sz * 0.35, cy + sz * 0.12); CTX.lineTo(cx - sz * 0.15, cy + sz * 0.3); CTX.stroke();
  CTX.restore();
}
function iconDestroy(cx, cy, sz, col) {
  CTX.save(); CTX.strokeStyle = col; CTX.lineWidth = 2.5 * S; CTX.lineCap = 'round';
  CTX.beginPath(); CTX.moveTo(cx - sz * 0.25, cy - sz * 0.25); CTX.lineTo(cx + sz * 0.25, cy + sz * 0.25);
  CTX.moveTo(cx + sz * 0.25, cy - sz * 0.25); CTX.lineTo(cx - sz * 0.25, cy + sz * 0.25); CTX.stroke();
  CTX.beginPath(); CTX.arc(cx, cy, sz * 0.35, 0, Math.PI * 2); CTX.stroke();
  CTX.restore();
}
function iconX2(cx, cy, sz, col) {
  CTX.save();
  drawText('x2', cx, cy, sz * 0.7, col, col);
  CTX.restore();
}

/* ===== CELL POSITION ===== */
function cellXY(r, c) {
  return { x: GX + PAD + c * (CS + PAD), y: GY + PAD + r * (CS + PAD) };
}

/* ===== DRAW TILE ===== */
function drawTile(x, y, val, scale, alpha) {
  if (!val) return;
  const c = tileColor(val);
  CTX.save();
  CTX.globalAlpha = alpha !== undefined ? alpha : 1;
  const s = scale || 1;
  const cx = x + CS / 2, cy = y + CS / 2;
  const w = CS * s, h = CS * s;
  const sx = cx - w / 2, sy = cy - h / 2;
  drawBox(sx, sy, w, h, RAD, c.bg, c.bd, 2.5 * S, c.gl, 14 * S);
  // inner glow
  const gr = CTX.createRadialGradient(cx, cy, 0, cx, cy, w * 0.5);
  gr.addColorStop(0, c.bd + '18'); gr.addColorStop(1, 'transparent');
  roundRect(sx + 2, sy + 2, w - 4, h - 4, Math.max(RAD - 2, 1));
  CTX.fillStyle = gr; CTX.fill();
  // text
  const txt = val.toString();
  let fs;
  if (txt.length <= 2) fs = CS * 0.4 * s;
  else if (txt.length === 3) fs = CS * 0.32 * s;
  else fs = CS * 0.25 * s;
  CTX.font = `bold ${Math.round(fs)}px 'Segoe UI', Arial, sans-serif`;
  CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
  CTX.shadowColor = c.gl; CTX.shadowBlur = 10 * S;
  CTX.fillStyle = c.tx;
  CTX.fillText(txt, cx, cy);
  CTX.restore();
}

/* ===== GAME GRID ===== */
function drawGrid() {
  const gn = grid.length;
  // board background
  drawBox(GX, GY, GTOTAL, GTOTAL, RAD * 1.5, '#080820', '#1a1a55', 2 * S, '#1a1a55', 6 * S);
  // empty cells
  for (let r = 0; r < gn; r++) {
    for (let c = 0; c < gn; c++) {
      const p = cellXY(r, c);
      drawBox(p.x, p.y, CS, CS, RAD, '#0c0c2a', '#15153a', 1 * S);
    }
  }

  const now = performance.now();

  if (isAnim) {
    // slide animation
    let t = Math.min((now - animT) / 140, 1);
    t = t * (2 - t); // easeOutQuad
    for (const a of animTiles) {
      const fp = cellXY(a.fr, a.fc), tp = cellXY(a.tr, a.tc);
      drawTile(fp.x + (tp.x - fp.x) * t, fp.y + (tp.y - fp.y) * t, a.val, 1, 1);
    }
  } else if (swapAnim) {
    let t = Math.min((now - swapT) / 220, 1);
    t = t * (2 - t);
    for (let r = 0; r < gn; r++) for (let c = 0; c < gn; c++) {
      if (sw1 && r === sw1.r && c === sw1.c) continue;
      if (sw2 && r === sw2.r && c === sw2.c) continue;
      if (grid[r][c]) { const p = cellXY(r, c); drawTile(p.x, p.y, grid[r][c], 1, 1); }
    }
    if (sw1 && sw2) {
      const p1 = cellXY(sw1.r, sw1.c), p2 = cellXY(sw2.r, sw2.c);
      drawTile(p1.x + (p2.x - p1.x) * t, p1.y + (p2.y - p1.y) * t, sw1.val, 1, 1);
      drawTile(p2.x + (p1.x - p2.x) * t, p2.y + (p1.y - p2.y) * t, sw2.val, 1, 1);
    }
  } else {
    // static tiles
    for (let r = 0; r < gn; r++) for (let c = 0; c < gn; c++) {
      if (!grid[r][c]) continue;
      const p = cellXY(r, c);
      let ts = 1, al = 1;
      // new tile pop
      if (newTiles.some(n => n.r === r && n.c === c) && now - newT < 180) {
        const t2 = (now - newT) / 180;
        const eased = (function(t){let s=1.7;return--t*t*((s+1)*t+s)+1;})(t2);
        ts = 0.2 + 0.8 * eased;
        al = t2;
      }
      // merge pulse
      if (mergeTiles2.some(m => m.r === r && m.c === c) && now - animT < 320) {
        const el = now - animT - 140;
        if (el > 0) { const t2 = el / 180; ts = t2 < 0.5 ? 1 + 0.15 * t2 * 2 : 1.15 - 0.15 * (t2 - 0.5) * 2; }
      }
      // swap highlight
      if (swapMode && swapFirst && swapFirst.r === r && swapFirst.c === c) {
        ts = 1 + 0.06 * Math.sin(now * 0.006);
        CTX.save();
        CTX.strokeStyle = '#00ddff'; CTX.lineWidth = 3 * S;
        CTX.shadowColor = '#00ddff'; CTX.shadowBlur = 14 * S;
        CTX.beginPath(); CTX.arc(p.x + CS / 2, p.y + CS / 2, CS * 0.54, 0, Math.PI * 2); CTX.stroke();
        CTX.restore();
      }
      // destroy highlight
      if (destroyMode) {
        CTX.save(); CTX.strokeStyle = '#ff333366'; CTX.lineWidth = 2 * S;
        CTX.setLineDash([5 * S, 5 * S]);
        CTX.strokeRect(p.x + 1, p.y + 1, CS - 2, CS - 2);
        CTX.setLineDash([]); CTX.restore();
      }
      drawTile(p.x, p.y, grid[r][c], ts, al);
    }
  }

  // hint arrow
  if (hintDir && now - hintT < 1500) {
    const t2 = (now - hintT) / 1500;
    const al = Math.max(0, (t2 < 0.5 ? 1 : 1 - (t2 - 0.5) * 2)) * 0.7;
    if (al > 0) drawArrow(hintDir, al, now);
  } else hintDir = null;
}

function drawArrow(dir, alpha, now) {
  CTX.save(); CTX.globalAlpha = alpha;
  const cx = GX + GTOTAL / 2, cy = GY + GTOTAL / 2, len = GTOTAL * 0.25;
  CTX.strokeStyle = '#00ddff'; CTX.lineWidth = 4 * S;
  CTX.shadowColor = '#00ddff'; CTX.shadowBlur = 12 * S;
  CTX.lineCap = 'round'; CTX.lineJoin = 'round';
  const p = 1 + 0.1 * Math.sin(now * 0.01);
  CTX.beginPath();
  const offsets = { up: [0, -1], down: [0, 1], left: [-1, 0], right: [1, 0] };
  const [dx, dy] = offsets[dir];
  CTX.moveTo(cx - dx * len * 0.3, cy - dy * len * 0.3);
  CTX.lineTo(cx + dx * len * 0.3 * p, cy + dy * len * 0.3 * p);
  const ex = cx + dx * len * 0.3 * p, ey = cy + dy * len * 0.3 * p;
  const perpX = -dy, perpY = dx;
  CTX.moveTo(ex - (dx + perpX) * len * 0.15, ey - (dy + perpY) * len * 0.15);
  CTX.lineTo(ex, ey);
  CTX.lineTo(ex - (dx - perpX) * len * 0.15, ey - (dy - perpY) * len * 0.15);
  CTX.stroke(); CTX.restore();
}

/* ===== PARTICLES & FLOATS ===== */
function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.06 * S; p.life -= p.decay;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    CTX.save(); CTX.globalAlpha = p.life * 0.7;
    CTX.fillStyle = p.color; CTX.shadowColor = p.color; CTX.shadowBlur = 3 * S;
    CTX.beginPath(); CTX.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2); CTX.fill();
    CTX.restore();
  }
}

function updateFloats() {
  for (let i = floats.length - 1; i >= 0; i--) {
    const f = floats[i];
    f.y -= 0.6 * S; f.life -= 0.01;
    if (f.life <= 0) { floats.splice(i, 1); continue; }
    drawText(f.text, f.x, f.y, 14 * S * Math.min(f.life * 3, 1), f.color, f.color);
  }
}

function spawnParticles(r, c, color, n) {
  const p = cellXY(r, c), cx = p.x + CS / 2, cy = p.y + CS / 2;
  for (let i = 0; i < n; i++) {
    const a = Math.random() * Math.PI * 2, sp = 1 + Math.random() * 3;
    particles.push({ x: cx, y: cy, vx: Math.cos(a) * sp * S, vy: Math.sin(a) * sp * S, life: 1, decay: 0.02 + Math.random() * 0.02, r: (1 + Math.random() * 2) * S, color });
  }
}

function addFloat(text, x, y, color) {
  floats.push({ text, x, y, life: 1, color: color || '#ffaa44' });
}

/* ===== BACKGROUND ===== */
let bgDots = [];
function initBg() {
  bgDots = [];
  const cols = ['#2233aa22', '#22aa6622', '#aa333322', '#aa882222', '#8822aa22'];
  for (let i = 0; i < 40; i++) {
    bgDots.push({ x: Math.random() * W, y: Math.random() * H, vx: (Math.random() - 0.5) * 0.25, vy: (Math.random() - 0.5) * 0.25, r: Math.random() * 2 + 0.5, c: cols[i % cols.length] });
  }
}

function drawBackground() {
  // gradient bg
  const gr = CTX.createLinearGradient(0, 0, 0, H);
  gr.addColorStop(0, '#050518'); gr.addColorStop(1, '#0a0a25');
  CTX.fillStyle = gr; CTX.fillRect(0, 0, W, H);
  // dots
  for (const d of bgDots) {
    d.x += d.vx; d.y += d.vy;
    if (d.x < 0) d.x = W; if (d.x > W) d.x = 0;
    if (d.y < 0) d.y = H; if (d.y > H) d.y = 0;
    CTX.beginPath(); CTX.arc(d.x, d.y, d.r * S, 0, Math.PI * 2);
    CTX.fillStyle = d.c; CTX.fill();
  }
}

/* ===== GAME LOGIC ===== */
function newGame() {
  const gn = MODES[curMode].grid;
  grid = Array.from({ length: gn }, () => Array(gn).fill(0));
  addRandomTile(); addRandomTile();
  score = 0; prevGrid = cloneGrid(grid); prevScore = 0;
  contWin = false; revives = 0;
  combo = 0; maxCombo = 0; totalMerges = 0;
  x2Active = false; swapMode = false; swapFirst = null; destroyMode = false;
  animTiles = []; newTiles = []; mergeTiles2 = [];
  hintDir = null; particles = []; floats = [];
  timerPaused = 0; timerPauseAt = 0;
  if (MODES[curMode].timed) { timerStart = Date.now(); timeLeft = MODES[curMode].time; }
  lastAdTime = Date.now();
  savedMode = curMode;
  recalcGrid();
  gameState = 'playing';
  gpStart();
}

function addRandomTile() {
  const gn = grid.length; const empty = [];
  for (let r = 0; r < gn; r++) for (let c = 0; c < gn; c++) if (!grid[r][c]) empty.push({ r, c });
  if (!empty.length) return;
  const cell = empty[Math.floor(Math.random() * empty.length)];
  grid[cell.r][cell.c] = Math.random() < 0.9 ? 2 : 4;
  newTiles = [cell]; newT = performance.now();
  SFX.play('spawn');
}

function canMove() {
  const gn = grid.length;
  for (let r = 0; r < gn; r++) for (let c = 0; c < gn; c++) {
    if (!grid[r][c]) return true;
    if (c < gn - 1 && grid[r][c] === grid[r][c + 1]) return true;
    if (r < gn - 1 && grid[r][c] === grid[r + 1][c]) return true;
  }
  return false;
}

function move(dir) {
  if (isAnim || swapAnim || gamePaused) return false;
  const gn = grid.length;
  prevGrid = cloneGrid(grid); prevScore = score;
  let moved = false; animTiles = []; mergeTiles2 = [];
  let mergeN = 0;
  const ng = Array.from({ length: gn }, () => Array(gn).fill(0));

  function processLine(cells, rev) {
    let items = cells.filter(c => c.val !== 0);
    if (rev) items.reverse();
    const merged = []; const used = [];
    for (let i = 0; i < items.length; i++) {
      if (i < items.length - 1 && items[i].val === items[i + 1].val && !used[i]) {
        let mv = items[i].val * 2;
        let bonus = x2Active ? mv : 0;
        if (x2Active) x2Active = false;
        score += mv + bonus;
        merged.push({ val: mv, from: [items[i], items[i + 1]], merge: true });
        used[i] = used[i + 1] = true; i++;
        mergeN++; totalMerges++;
        let ec = 0;
        if (mv >= 64) ec++; if (mv >= 256) ec += 2; if (mv >= 1024) ec += 5; if (mv >= 2048) ec += 10;
        coins += ec; if (ec > 0) SFX.play('coin');
        if (bonus > 0) addFloat('+' + bonus + ' x2!', W / 2, GY - 20 * S, '#ff44aa');
      } else {
        merged.push({ val: items[i].val, from: [items[i]], merge: false });
      }
    }
    if (rev) merged.reverse();
    return merged;
  }

  for (let i = 0; i < gn; i++) {
    let cells;
    if (dir === 'left' || dir === 'right') {
      cells = []; for (let c = 0; c < gn; c++) cells.push({ val: grid[i][c], or: i, oc: c });
    } else {
      cells = []; for (let r = 0; r < gn; r++) cells.push({ val: grid[r][i], or: r, oc: i });
    }
    const rev = dir === 'right' || dir === 'down';
    const merged = processLine(cells, rev);
    for (let j = 0; j < merged.length; j++) {
      let destR, destC;
      if (dir === 'left') { destR = i; destC = j; }
      else if (dir === 'right') { destR = i; destC = gn - merged.length + j; }
      else if (dir === 'up') { destR = j; destC = i; }
      else { destR = gn - merged.length + j; destC = i; }
      ng[destR][destC] = merged[j].val;
      for (const f of merged[j].from) {
        if (f.or !== destR || f.oc !== destC) moved = true;
        animTiles.push({ fr: f.or, fc: f.oc, tr: destR, tc: destC, val: f.val });
      }
      if (merged[j].merge) {
        mergeTiles2.push({ r: destR, c: destC, val: merged[j].val });
        spawnParticles(destR, destC, tileColor(merged[j].val).gl, merged[j].val >= 128 ? 14 : 7);
      }
    }
  }

  if (moved || JSON.stringify(grid) !== JSON.stringify(ng)) {
    grid = ng; isAnim = true; animT = performance.now();
    if (mergeN > 0) {
      combo += mergeN; if (combo > maxCombo) maxCombo = combo;
      SFX.play(mergeN >= 2 ? 'bigmerge' : 'merge');
      if (combo >= 3) addFloat('Combo x' + combo + '!', W / 2, GY + GTOTAL / 2, '#ffaa44');
    } else combo = 0;
    SFX.play('swipe');

    setTimeout(() => {
      addRandomTile(); isAnim = false;
      const target = MODES[curMode].target;
      if (!contWin && maxTile() >= target) {
        contWin = false; gameState = 'win'; gpStop(); happytime(); SFX.play('win');
        coins += 50; stars += 2; addToLB(); tryMidAd();
      } else if (!canMove() && !MODES[curMode].zen) {
        gameState = 'gameover'; gpStop(); SFX.play('lose'); addToLB(); tryMidAd();
      }
      if (score > best) best = score;
      checkAch(); saveAll();
    }, 180);
    return true;
  }
  return false;
}

function addToLB() {
  lb.push({ score, mode: MODES[curMode].name, date: new Date().toLocaleDateString() });
  lb.sort((a, b) => b.score - a.score);
  if (lb.length > 20) lb = lb.slice(0, 20);
}

function checkAch() {
  for (const a of ACHS) {
    if (!unlocked.includes(a.id) && a.fn()) {
      unlocked.push(a.id); coins += 25; stars++;
      achPopup = a; achPopupT = performance.now();
      SFX.play('star'); saveAll();
    }
  }
}

function calcHint() {
  const gn = grid.length; let bd = null, bs = -1;
  for (const dir of ['up', 'down', 'left', 'right']) {
    const tg = cloneGrid(grid); let ts = 0;
    const ng2 = Array.from({ length: gn }, () => Array(gn).fill(0));
    for (let i = 0; i < gn; i++) {
      let cells;
      if (dir === 'left' || dir === 'right') { cells = []; for (let c = 0; c < gn; c++) cells.push(tg[i][c]); }
      else { cells = []; for (let r = 0; r < gn; r++) cells.push(tg[r][i]); }
      if (dir === 'right' || dir === 'down') cells.reverse();
      const items = cells.filter(v => v); const merged = [];
      for (let j = 0; j < items.length; j++) {
        if (j < items.length - 1 && items[j] === items[j + 1]) { merged.push(items[j] * 2); ts += items[j] * 2; j++; }
        else merged.push(items[j]);
      }
      if (dir === 'right' || dir === 'down') merged.reverse();
      for (let j = 0; j < merged.length; j++) {
        if (dir === 'left') ng2[i][j] = merged[j];
        else if (dir === 'right') ng2[i][gn - merged.length + j] = merged[j];
        else if (dir === 'up') ng2[j][i] = merged[j];
        else ng2[gn - merged.length + j][i] = merged[j];
      }
    }
    if (JSON.stringify(tg) !== JSON.stringify(ng2)) { if (ts > bs) { bs = ts; bd = dir; } if (!bd) bd = dir; }
  }
  if (bd) { hintDir = bd; hintT = performance.now(); }
}

/* ===== SAVE/LOAD ===== */
function saveAll() {
  try {
    const d = { grid, score, best, coins, stars, powers, curMode, savedMode, revives, contWin, lb, unlocked, dailyStreak, lastDaily, muted: SFX.muted, rateShown };
    localStorage.setItem('n2048f', JSON.stringify(d));
  } catch(e) {}
}

function loadAll() {
  try {
    const raw = localStorage.getItem('n2048f');
    if (!raw) return;
    const d = JSON.parse(raw);
    if (d.best !== undefined) best = d.best;
    if (d.coins !== undefined) coins = d.coins;
    if (d.stars !== undefined) stars = d.stars;
    if (d.powers) Object.assign(powers, d.powers);
    if (d.curMode !== undefined) curMode = d.curMode;
    if (d.savedMode !== undefined) savedMode = d.savedMode; else savedMode = -1;
    if (d.lb) lb = d.lb;
    if (d.unlocked) unlocked = d.unlocked;
    if (d.dailyStreak !== undefined) dailyStreak = d.dailyStreak;
    if (d.lastDaily) lastDaily = d.lastDaily;
    if (d.muted) SFX.muted = true;
    if (d.rateShown) rateShown = true;
  } catch(e) {}
}

function loadSavedGame() {
  try {
    const raw = localStorage.getItem('n2048f');
    if (!raw) return false;
    const d = JSON.parse(raw);
    if (!d.grid || !d.grid.length) return false;
    grid = d.grid; score = d.score || 0;
    contWin = d.contWin || false;
    revives = d.revives || 0;
    prevGrid = cloneGrid(grid); prevScore = score;
    return true;
  } catch(e) { return false; }
}

function canContinue() { return savedMode === curMode && (() => { try { const d = JSON.parse(localStorage.getItem('n2048f')); return d && d.grid && d.grid.length > 0; } catch(e) { return false; } })(); }

function checkDaily() {
  const today = new Date().toDateString();
  if (lastDaily !== today) {
    if (lastDaily) {
      const diff = Math.round((new Date(today) - new Date(lastDaily)) / 86400000);
      dailyStreak = diff === 1 ? dailyStreak + 1 : 1;
    } else dailyStreak = 1;
    lastDaily = today;
    const bonus = Math.min(dailyStreak * 10, 100);
    coins += bonus;
    addFloat('Day ' + dailyStreak + '! +' + bonus + ' coins', W / 2, H * 0.4, '#ffaa44');
    SFX.play('coin'); saveAll();
  }
}

function shareScore() {
  const text = 'I scored ' + score + ' in Neon 2048 Fusion (' + MODES[curMode].name + ')! Can you beat me?';
  if (navigator.share) { navigator.share({ title: 'Neon 2048 Fusion', text, url: location.href }).catch(() => {}); }
  else { try { navigator.clipboard.writeText(text + ' ' + location.href); addFloat('Copied!', W / 2, H / 2, '#44ffaa'); } catch(e) {} }
}

/* ===== SCREENS ===== */
function drawHUD() {
  const top = 8 * S;
  const titleSz = Math.min(28 * S, W * 0.07);
  drawText('NEON 2048 FUSION', W / 2, top + titleSz * 0.5, titleSz, '#00ccee', '#00ccee');

  const modeSz = Math.min(10 * S, W * 0.025);
  let mStr = MODES[curMode].name;
  if (MODES[curMode].zen) mStr += ' (endless)';
  drawText(mStr, W / 2, top + titleSz + 5 * S, modeSz, '#8844cc', '#8844cc');

  // stars top right
  drawText('Stars: ' + stars, W - 12 * S, top + 10 * S, Math.min(10 * S, W * 0.024), '#dddd44', '#dddd44', 'right');

  // score boxes
  const bw = Math.min(W * 0.22, 88 * S), bh = Math.min(H * 0.052, 38 * S);
  const by = top + titleSz + 14 * S;
  const gap = 8 * S;
  const tw = bw * 3 + gap * 2;
  const sx = (W - tw) / 2;

  drawBox(sx, by, bw, bh, RAD, '#0808208', '#2244cc', 1.5 * S, '#2244cc', 4 * S);
  drawBox(sx + bw + gap, by, bw, bh, RAD, '#080820', '#cc2288', 1.5 * S, '#cc2288', 4 * S);
  drawBox(sx + (bw + gap) * 2, by, bw, bh, RAD, '#080820', '#cc8822', 1.5 * S, '#cc8822', 4 * S);

  const lf = Math.min(bh * 0.28, 9 * S), vf = Math.min(bh * 0.42, 14 * S);
  drawText('SCORE', sx + bw / 2, by + bh * 0.3, lf, '#6677bb', '#3355aa');
  drawText(score.toString(), sx + bw / 2, by + bh * 0.7, vf, '#99aaff', '#4466cc');
  drawText('BEST', sx + bw + gap + bw / 2, by + bh * 0.3, lf, '#bb6688', '#aa3366');
  drawText(best.toString(), sx + bw + gap + bw / 2, by + bh * 0.7, vf, '#ff99bb', '#cc4488');
  drawText('COINS', sx + (bw + gap) * 2 + bw / 2, by + bh * 0.3, lf, '#bb8866', '#aa6633');
  drawText(coins.toString(), sx + (bw + gap) * 2 + bw / 2, by + bh * 0.7, vf, '#ffcc88', '#cc8844');

  if (combo >= 2) {
    const csz = Math.min(13 * S, W * 0.033);
    drawText('Combo x' + combo, W / 2, by + bh + 9 * S, csz * (1 + 0.08 * Math.sin(performance.now() * 0.008)), '#ffaa44', '#ffaa44');
  }
  if (x2Active) drawText('x2 ACTIVE', W / 2, GY - 10 * S, Math.min(12 * S, W * 0.03), '#ff44aa', '#ff44aa');

  // timer
  if (MODES[curMode].timed && gameState === 'playing') {
    const elapsed = (Date.now() - timerStart - timerPaused) / 1000;
    timeLeft = Math.max(0, MODES[curMode].time - elapsed);
    if (timeLeft <= 0) { gameState = 'gameover'; gpStop(); SFX.play('lose'); addToLB(); tryMidAd(); }
    const m = Math.floor(timeLeft / 60), s2 = Math.floor(timeLeft % 60);
    const tc = timeLeft < 30 ? '#ff3333' : '#33ddaa';
    drawText(m + ':' + (s2 < 10 ? '0' : '') + s2, W / 2, GY - 10 * S, Math.min(16 * S, W * 0.04), tc, tc);
  }
}

function drawPowerButtons() {
  btns = [];
  const py = GY + GTOTAL + 10 * S;
  const pw = Math.min((W - 40 * S) / 5, 68 * S);
  const ph = Math.min(H * 0.072, 56 * S);
  const gap = 5 * S;
  const tw2 = pw * 5 + gap * 4;
  const sx = (W - tw2) / 2;

  const items = [
    { fn: iconUndo, text: 'Undo', col: '#3366ff', act: 'undo', cnt: powers.undo },
    { fn: iconHint, text: 'Hint', col: '#33cc88', act: 'hint', cnt: powers.hint },
    { fn: iconSwap, text: swapMode ? 'Off' : 'Swap', col: swapMode ? '#00ccff' : '#cc8833', act: 'swap', cnt: powers.swap },
    { fn: iconDestroy, text: destroyMode ? 'Off' : 'Break', col: destroyMode ? '#ff2222' : '#cc3333', act: 'destroy', cnt: powers.destroy },
    { fn: iconX2, text: 'x2', col: x2Active ? '#ff44aa' : '#8833cc', act: 'x2', cnt: powers.x2 },
  ];

  items.forEach((it, i) => {
    const bx = sx + i * (pw + gap);
    const b = { x: bx, y: py, w: pw, h: ph, action: it.act };
    drawIconButton(bx, py, pw, ph, it.text, it.col, (it.act === 'swap' && swapMode) || (it.act === 'destroy' && destroyMode), it.fn, it.cnt);
    btns.push(b);
  });

  if (swapMode || destroyMode) {
    const msg = destroyMode ? 'Tap a tile to destroy' : (swapFirst ? 'Tap second tile' : 'Tap first tile');
    drawText(msg, W / 2, py + ph + 7 * S, Math.min(11 * S, W * 0.027), '#00ccff', '#00ccff');
  }

  // bottom bar
  const bw2 = Math.min((W - 36 * S) / 4, 88 * S);
  const bh2 = Math.min(H * 0.035, 30 * S);
  const by2 = H - bh2 - 8 * S;
  const tw3 = bw2 * 4 + gap * 3;
  const sx2 = (W - tw3) / 2;
  const bar = [
    { t: 'Menu', a: 'menu', c: '#5566aa' },
    { t: 'Shop', a: 'shop', c: '#cc8833' },
    { t: 'Share', a: 'share', c: '#3399cc' },
    { t: SFX.muted ? 'Muted' : 'Sound', a: 'sound', c: '#33aa66' }
  ];
  bar.forEach((it, i) => {
    const b = { x: sx2 + i * (bw2 + gap), y: by2, w: bw2, h: bh2, action: it.a };
    drawButton(b.x, b.y, b.w, b.h, it.t, it.c, false);
    btns.push(b);
  });
}

function drawMenuScreen() {
  btns = [];
  const tf = Math.min(44 * S, W * 0.11);
  drawText('NEON 2048', W / 2, H * 0.09, tf, '#00ccee', '#00ccee');
  drawText('FUSION', W / 2, H * 0.09 + tf * 0.65, Math.min(16 * S, W * 0.04), '#cc44aa', '#cc44aa');
  if (dailyStreak > 0) drawText('Day ' + dailyStreak + ' streak!', W / 2, H * 0.09 + tf * 1.1, Math.min(10 * S, W * 0.024), '#ffaa44', '#ffaa44');

  // divider
  CTX.save(); CTX.strokeStyle = '#1a1a55'; CTX.lineWidth = 1; CTX.shadowColor = '#3344aa'; CTX.shadowBlur = 4 * S;
  const lw = Math.min(W * 0.55, 220 * S);
  CTX.beginPath(); CTX.moveTo(W / 2 - lw / 2, H * 0.19); CTX.lineTo(W / 2 + lw / 2, H * 0.19); CTX.stroke(); CTX.restore();

  // mode selector
  drawText('Game Mode:', W / 2, H * 0.22, Math.min(11 * S, W * 0.028), '#777', '#777');
  const mw = Math.min(W * 0.55, 200 * S), mh = Math.min(H * 0.034, 28 * S);
  let my = H * 0.25;
  MODES.forEach((m, i) => {
    const b = { x: (W - mw) / 2, y: my + i * (mh + 4 * S), w: mw, h: mh, action: 'mode_' + i };
    const label = m.name + (m.timed ? ' [' + m.time + 's]' : '') + (m.zen ? ' [zen]' : '');
    drawButton(b.x, b.y, b.w, b.h, label, i === curMode ? '#00ccee' : '#333366', i === curMode);
    btns.push(b);
  });

  const startY = my + MODES.length * (mh + 4 * S) + 10 * S;
  const bw = Math.min(W * 0.52, 195 * S), bh = Math.min(H * 0.046, 38 * S);
  const gap2 = 8 * S;

  // New Game
  const b1 = { x: (W - bw) / 2, y: startY, w: bw, h: bh, action: 'newgame' };
  drawButton(b1.x, b1.y, b1.w, b1.h, 'New Game', '#33aa66', false);
  btns.push(b1);

  // Continue
  const contY = startY + bh + gap2;
  if (canContinue()) {
    const b2 = { x: (W - bw) / 2, y: contY, w: bw, h: bh, action: 'continue' };
    drawButton(b2.x, b2.y, b2.w, b2.h, 'Continue', '#3366cc', false);
    btns.push(b2);
  } else {
    drawButtonDim((W - bw) / 2, contY, bw, bh, 'Continue');
  }

  // Leaderboard & Achievements
  const row2Y = contY + bh + gap2;
  const bw3 = Math.min((W - 30 * S) / 2, 140 * S);
  const b3 = { x: W / 2 - bw3 - 4 * S, y: row2Y, w: bw3, h: bh, action: 'leaderboard' };
  drawButton(b3.x, b3.y, b3.w, b3.h, 'Leaderboard', '#8844cc', false); btns.push(b3);
  const b4 = { x: W / 2 + 4 * S, y: row2Y, w: bw3, h: bh, action: 'achievements' };
  drawButton(b4.x, b4.y, b4.w, b4.h, 'Achievements', '#cc8833', false); btns.push(b4);

  // Info
  const iy = row2Y + bh + 12 * S;
  drawText('Coins: ' + coins + '   Stars: ' + stars, W / 2, iy, Math.min(12 * S, W * 0.03), '#cc8833', '#cc8833');
  drawText('Best: ' + best, W / 2, iy + 18 * S, Math.min(11 * S, W * 0.027), '#cc4488', '#cc4488');

  // Sound
  const sw2 = Math.min(W * 0.28, 110 * S), sh = Math.min(H * 0.03, 24 * S);
  const sb = { x: (W - sw2) / 2, y: H - sh - 8 * S, w: sw2, h: sh, action: 'sound' };
  drawButton(sb.x, sb.y, sb.w, sb.h, SFX.muted ? 'Sound OFF' : 'Sound ON', '#33aa66', false);
  btns.push(sb);
}

function drawShopScreen() {
  btns = [];
  drawText('SHOP', W / 2, H * 0.05, Math.min(26 * S, W * 0.065), '#cc8833', '#cc8833');
  drawText('Coins: ' + coins, W / 2, H * 0.09, Math.min(13 * S, W * 0.033), '#cc8833', '#cc8833');

  const bw = Math.min(W * 0.72, 260 * S), bh = Math.min(H * 0.058, 44 * S);
  let sy = H * 0.13;
  const gap2 = 6 * S;

  SHOP_ITEMS.forEach((item, i) => {
    const y = sy + i * (bh + gap2);
    const canBuy = coins >= item.cost;
    const col = canBuy ? '#33aa66' : '#333344';
    const b = { x: (W - bw) / 2, y, w: bw, h: bh, action: 'buy_' + item.id };
    drawBox(b.x, b.y, b.w, b.h, RAD, '#08082088', col, 2 * S, col, (canBuy ? 6 : 2) * S);
    drawText(item.name, b.x + 12 * S, b.y + bh * 0.35, fitSize(item.name, bw * 0.3, 13 * S), col, col, 'left');
    drawText(item.desc, b.x + 12 * S, b.y + bh * 0.7, fitSize(item.desc, bw * 0.4, 9 * S), '#777', '#777', 'left');
    drawText(item.cost + 'c', b.x + bw - 12 * S, b.y + bh * 0.35, fitSize(item.cost + 'c', bw * 0.2, 12 * S), canBuy ? '#ffaa44' : '#444', canBuy ? '#ffaa44' : '#444', 'right');
    drawText('Have: ' + powers[item.id], b.x + bw - 12 * S, b.y + bh * 0.7, 9 * S, '#777', '#777', 'right');
    btns.push(b);
  });

  const adY = sy + SHOP_ITEMS.length * (bh + gap2) + 10 * S;
  const ab = { x: (W - bw) / 2, y: adY, w: bw, h: bh, action: 'adcoins' };
  drawButton(ab.x, ab.y, ab.w, ab.h, 'Watch Ad = +30 Coins', '#8844cc', false);
  btns.push(ab);

  const bk = { x: (W - 110 * S) / 2, y: H - 32 * S, w: 110 * S, h: 26 * S, action: 'back' };
  drawButton(bk.x, bk.y, bk.w, bk.h, 'Back', '#5566aa', false);
  btns.push(bk);
}

function drawLBScreen() {
  btns = [];
  drawText('LEADERBOARD', W / 2, H * 0.05, Math.min(22 * S, W * 0.055), '#8844cc', '#8844cc');
  const bw = Math.min(W * 0.78, 280 * S), rh = Math.min(H * 0.038, 28 * S);
  let sy = H * 0.1;
  if (!lb.length) drawText('No scores yet!', W / 2, H * 0.3, 14 * S, '#555', '#555');
  else for (let i = 0; i < Math.min(lb.length, 10); i++) {
    const e = lb[i], y = sy + i * (rh + 3 * S);
    const col = i === 0 ? '#ffaa44' : i === 1 ? '#99aacc' : i === 2 ? '#cc8844' : '#556688';
    drawBox((W - bw) / 2, y, bw, rh, RAD, '#0808208', col, 1 * S, col, 3 * S);
    drawText('#' + (i + 1), (W - bw) / 2 + 16 * S, y + rh / 2, 11 * S, col, col, 'left');
    drawText(e.score.toString(), W / 2, y + rh / 2, 12 * S, col, col);
    drawText(e.mode, (W + bw) / 2 - 12 * S, y + rh / 2, 9 * S, '#777', '#777', 'right');
  }
  const bk = { x: (W - 110 * S) / 2, y: H - 32 * S, w: 110 * S, h: 26 * S, action: 'back' };
  drawButton(bk.x, bk.y, bk.w, bk.h, 'Back', '#5566aa', false); btns.push(bk);
}

function drawAchScreen() {
  btns = [];
  drawText('ACHIEVEMENTS', W / 2, H * 0.05, Math.min(22 * S, W * 0.055), '#cc8833', '#cc8833');
  drawText(unlocked.length + '/' + ACHS.length, W / 2, H * 0.09, 11 * S, '#777', '#777');
  const bw = Math.min(W * 0.78, 280 * S), rh = Math.min(H * 0.048, 36 * S);
  let sy = H * 0.12;
  ACHS.forEach((a, i) => {
    const y = sy + i * (rh + 3 * S);
    const u = unlocked.includes(a.id);
    const col = u ? '#33aa66' : '#2a2a3a';
    drawBox((W - bw) / 2, y, bw, rh, RAD, '#08082088', col, 1 * S, col, (u ? 4 : 1) * S);
    drawText(a.name, (W - bw) / 2 + 12 * S, y + rh * 0.35, 11 * S, u ? '#33cc77' : '#444', u ? '#33cc77' : '#444', 'left');
    drawText(a.desc, (W - bw) / 2 + 12 * S, y + rh * 0.72, 9 * S, u ? '#999' : '#333', '#666', 'left');
    if (u) drawText('*', (W + bw) / 2 - 16 * S, y + rh / 2, 14 * S, '#dddd44', '#dddd44');
  });
  const bk = { x: (W - 110 * S) / 2, y: H - 32 * S, w: 110 * S, h: 26 * S, action: 'back' };
  drawButton(bk.x, bk.y, bk.w, bk.h, 'Back', '#5566aa', false); btns.push(bk);
}

function drawGameOverScreen() {
  CTX.save(); CTX.fillStyle = '#050515dd'; CTX.fillRect(0, 0, W, H);
  drawText('Game Over', W / 2, H * 0.16, Math.min(32 * S, W * 0.08), '#ee3333', '#ee3333');
  drawText('Score: ' + score, W / 2, H * 0.22, Math.min(16 * S, W * 0.04), '#99aaff', '#4466cc');
  const ce = Math.floor(score / 100);
  drawText('+' + ce + ' coins', W / 2, H * 0.26, Math.min(12 * S, W * 0.03), '#ffaa44', '#ffaa44');
  btns = [];
  const bw = Math.min(W * 0.52, 200 * S), bh = Math.min(H * 0.046, 38 * S);
  let sy = H * 0.31; const g2 = 8 * S;
  if (revives < MAX_REV) {
    const br = { x: (W - bw) / 2, y: sy, w: bw, h: bh, action: 'revive' };
    drawButton(br.x, br.y, br.w, br.h, 'Revive (' + (MAX_REV - revives) + 'x)', '#cc8833', false); btns.push(br);
    drawText('Watch ad', W / 2, sy + bh + 4 * S, 9 * S, '#666', '#666');
    sy += bh + g2 + 8 * S;
  }
  const bs = { x: (W - bw) / 2, y: sy, w: bw, h: bh, action: 'share' };
  drawButton(bs.x, bs.y, bs.w, bs.h, 'Share Score', '#3399cc', false); btns.push(bs);
  const b1 = { x: (W - bw) / 2, y: sy + bh + g2, w: bw, h: bh, action: 'newgame' };
  drawButton(b1.x, b1.y, b1.w, b1.h, 'New Game', '#33aa66', false); btns.push(b1);
  const b2 = { x: (W - bw) / 2, y: sy + (bh + g2) * 2, w: bw, h: bh, action: 'menu' };
  drawButton(b2.x, b2.y, b2.w, b2.h, 'Menu', '#3366cc', false); btns.push(b2);
  CTX.restore();
}

function drawWinScreen() {
  CTX.save(); CTX.fillStyle = '#050515dd'; CTX.fillRect(0, 0, W, H);
  drawText('You Win!', W / 2, H * 0.18, Math.min(32 * S, W * 0.08), '#00ccee', '#00ccee');
  drawText('Score: ' + score, W / 2, H * 0.24, Math.min(16 * S, W * 0.04), '#99aaff', '#4466cc');
  drawText('+50 coins +2 stars!', W / 2, H * 0.28, Math.min(12 * S, W * 0.03), '#ffaa44', '#ffaa44');
  btns = [];
  const bw = Math.min(W * 0.52, 200 * S), bh = Math.min(H * 0.046, 38 * S);
  let sy = H * 0.33; const g2 = 8 * S;
  const bs = { x: (W - bw) / 2, y: sy, w: bw, h: bh, action: 'share' };
  drawButton(bs.x, bs.y, bs.w, bs.h, 'Share Victory!', '#3399cc', false); btns.push(bs);
  const b1 = { x: (W - bw) / 2, y: sy + bh + g2, w: bw, h: bh, action: 'continueplay' };
  drawButton(b1.x, b1.y, b1.w, b1.h, 'Continue Playing', '#33aa66', false); btns.push(b1);
  const b2 = { x: (W - bw) / 2, y: sy + (bh + g2) * 2, w: bw, h: bh, action: 'newgame' };
  drawButton(b2.x, b2.y, b2.w, b2.h, 'New Game', '#cc8833', false); btns.push(b2);
  const b3 = { x: (W - bw) / 2, y: sy + (bh + g2) * 3, w: bw, h: bh, action: 'menu' };
  drawButton(b3.x, b3.y, b3.w, b3.h, 'Menu', '#3366cc', false); btns.push(b3);
  CTX.restore();
}

function drawTutorialScreen() {
  CTX.save(); CTX.fillStyle = '#050515f0'; CTX.fillRect(0, 0, W, H);
  const msgs = [
    'Swipe to move all tiles.\nMatching tiles merge together!',
    'Reach ' + MODES[curMode].target + ' to win!\nBig merges earn coins.',
    'Use powers: Undo, Hint,\nSwap, Destroy, Score x2!',
    'Buy powers in the Shop.\nWatch ads for free coins!',
    'Good luck!\nTap Start to play.'
  ];
  const msg = msgs[Math.min(tutStep, msgs.length - 1)];
  const lines = msg.split('\n');
  const fs = Math.min(16 * S, W * 0.04);
  lines.forEach((l, i) => drawText(l, W / 2, H * 0.35 + i * fs * 1.8, fs, '#00ccee', '#00ccee'));
  let dots = '';
  for (let i = 0; i < msgs.length; i++) dots += i === tutStep ? ' O ' : ' . ';
  drawText(dots, W / 2, H * 0.52, 13 * S, '#555', '#555');
  btns = [];
  const bw = Math.min(W * 0.38, 140 * S), bh = Math.min(H * 0.042, 34 * S);
  if (tutStep < msgs.length - 1) {
    const b = { x: (W - bw) / 2, y: H * 0.58, w: bw, h: bh, action: 'tutnext' };
    drawButton(b.x, b.y, b.w, b.h, 'Next', '#33aa66', false); btns.push(b);
  } else {
    const b = { x: (W - bw) / 2, y: H * 0.58, w: bw, h: bh, action: 'tutdone' };
    drawButton(b.x, b.y, b.w, b.h, 'Start!', '#00ccee', false); btns.push(b);
  }
  const bs = { x: (W - bw) / 2, y: H * 0.58 + bh + 8 * S, w: bw, h: bh, action: 'tutskip' };
  drawButton(bs.x, bs.y, bs.w, bs.h, 'Skip', '#556688', false); btns.push(bs);
  CTX.restore();
}

function drawRatePopup() {
  if (!showRate) return;
  CTX.save(); CTX.fillStyle = '#000000cc'; CTX.fillRect(0, 0, W, H);
  const pw = Math.min(W * 0.82, 310 * S), ph = Math.min(H * 0.3, 180 * S);
  const px = (W - pw) / 2, py = (H - ph) / 2;
  drawBox(px, py, pw, ph, RAD * 2, '#0a0a28', '#8844cc', 2.5 * S, '#8844cc', 12 * S);
  drawText('Help us improve!', W / 2, py + ph * 0.17, Math.min(18 * S, W * 0.045), '#aa66dd', '#8844cc');
  drawText('Rate the game and get', W / 2, py + ph * 0.38, Math.min(12 * S, W * 0.03), '#aaa', '#aaa');
  drawText('200 bonus coins!', W / 2, py + ph * 0.52, Math.min(14 * S, W * 0.035), '#ffaa44', '#ffaa44');
  btns = [];
  const bw = Math.min(pw * 0.38, 120 * S), bh = Math.min(ph * 0.2, 34 * S);
  const b1 = { x: W / 2 - bw - 6 * S, y: py + ph * 0.68, w: bw, h: bh, action: 'rate_yes' };
  drawButton(b1.x, b1.y, b1.w, b1.h, 'Rate!', '#33aa66', false); btns.push(b1);
  const b2 = { x: W / 2 + 6 * S, y: py + ph * 0.68, w: bw, h: bh, action: 'rate_later' };
  drawButton(b2.x, b2.y, b2.w, b2.h, 'Later', '#556688', false); btns.push(b2);
  CTX.restore();
}

function drawAchNotification() {
  if (!achPopup) return;
  const elapsed = performance.now() - achPopupT;
  if (elapsed > 3000) { achPopup = null; return; }
  const al = elapsed < 400 ? elapsed / 400 : elapsed > 2500 ? 1 - (elapsed - 2500) / 500 : 1;
  CTX.save(); CTX.globalAlpha = Math.max(0, al);
  const pw = Math.min(W * 0.72, 260 * S), ph = 40 * S;
  const px = (W - pw) / 2, py = 8 * S;
  drawBox(px, py, pw, ph, RAD, '#0a0a28ee', '#dddd44', 2 * S, '#dddd44', 8 * S);
  drawText(achPopup.name, W / 2, py + ph * 0.38, 12 * S, '#dddd44', '#dddd44');
  drawText('+25 coins +1 star', W / 2, py + ph * 0.72, 9 * S, '#ffaa44', '#ffaa44');
  CTX.restore();
}

/* ===== MAIN LOOP ===== */
function render() {
  if (gamePaused) { requestAnimationFrame(render); return; }

  drawBackground();

  if (showRate) {
    drawRatePopup();
  } else {
    switch (gameState) {
      case 'menu': drawMenuScreen(); break;
      case 'playing': drawHUD(); drawGrid(); updateParticles(); updateFloats(); drawPowerButtons(); break;
      case 'shop': drawShopScreen(); break;
      case 'leaderboard': drawLBScreen(); break;
      case 'achievements': drawAchScreen(); break;
      case 'gameover': drawHUD(); drawGrid(); updateParticles(); updateFloats(); drawGameOverScreen(); break;
      case 'win': drawHUD(); drawGrid(); updateParticles(); updateFloats(); drawWinScreen(); break;
      case 'tutorial': drawTutorialScreen(); break;
    }
  }

  drawAchNotification();

  // scanlines
  CTX.save(); CTX.globalAlpha = 0.015;
  for (let y = 0; y < H; y += 3) { CTX.fillStyle = '#000'; CTX.fillRect(0, y, W, 1); }
  CTX.restore();

  // swap anim end
  if (swapAnim && performance.now() - swapT >= 220) {
    swapAnim = false;
    if (sw1 && sw2) { const t = grid[sw1.r][sw1.c]; grid[sw1.r][sw1.c] = grid[sw2.r][sw2.c]; grid[sw2.r][sw2.c] = t; }
    sw1 = sw2 = null; swapMode = false; swapFirst = null;
  }

  // rate popup
  if (!rateShown && !showRate && rateTimer > 0 && Date.now() - rateTimer > 30000) { showRate = true; }

  requestAnimationFrame(render);
}

/* ===== INPUT ===== */
function cellAt(px, py) {
  const gn = grid.length;
  for (let r = 0; r < gn; r++) for (let c = 0; c < gn; c++) {
    const p = cellXY(r, c);
    if (px >= p.x && px <= p.x + CS && py >= p.y && py <= p.y + CS) return { r, c };
  }
  return null;
}

function handleTap(px, py) {
  if (gamePaused) return;
  SFX.resume();
  for (const b of btns) {
    if (px >= b.x && px <= b.x + b.w && py >= b.y && py <= b.y + b.h) {
      doAction(b.action); return true;
    }
  }
  if (gameState === 'playing' && !isAnim && !swapAnim) {
    const cell = cellAt(px, py);
    if (cell) {
      if (destroyMode && grid[cell.r][cell.c]) {
        prevGrid = cloneGrid(grid); prevScore = score;
        spawnParticles(cell.r, cell.c, '#ff3333', 12);
        grid[cell.r][cell.c] = 0; destroyMode = false;
        SFX.play('powerup'); return true;
      }
      if (swapMode && grid[cell.r][cell.c]) {
        if (!swapFirst) { swapFirst = cell; }
        else if (swapFirst.r === cell.r && swapFirst.c === cell.c) { swapFirst = null; }
        else {
          sw1 = { r: swapFirst.r, c: swapFirst.c, val: grid[swapFirst.r][swapFirst.c] };
          sw2 = { r: cell.r, c: cell.c, val: grid[cell.r][cell.c] };
          swapAnim = true; swapT = performance.now();
          prevGrid = cloneGrid(grid); prevScore = score;
          SFX.play('swipe');
        }
        return true;
      }
    }
  }
  return false;
}

function doAction(action) {
  SFX.play('click');

  if (action.startsWith('mode_')) {
    curMode = parseInt(action.split('_')[1]);
    recalcGrid();
    return;
  }
  if (action.startsWith('buy_')) {
    const id = action.split('_')[1];
    const item = SHOP_ITEMS.find(s => s.id === id);
    if (item && coins >= item.cost) { coins -= item.cost; powers[id]++; SFX.play('coin'); saveAll(); }
    return;
  }

  switch (action) {
    case 'newgame': newGame(); break;
    case 'continue':
      if (canContinue() && loadSavedGame()) {
        recalcGrid(); gameState = 'playing'; gpStart();
      }
      break;
    case 'continueplay': contWin = true; gameState = 'playing'; gpStart(); break;
    case 'undo':
      if (powers.undo > 0) { powers.undo--; grid = cloneGrid(prevGrid); score = prevScore; animTiles = []; mergeTiles2 = []; newTiles = []; SFX.play('click'); }
      else rewardAd(() => { grid = cloneGrid(prevGrid); score = prevScore; animTiles = []; mergeTiles2 = []; newTiles = []; SFX.play('powerup'); });
      break;
    case 'hint':
      if (powers.hint > 0) { powers.hint--; calcHint(); SFX.play('click'); }
      else rewardAd(() => { calcHint(); SFX.play('powerup'); });
      break;
    case 'swap':
      if (swapMode) { swapMode = false; swapFirst = null; return; }
      if (powers.swap > 0) { powers.swap--; swapMode = true; swapFirst = null; SFX.play('click'); }
      else rewardAd(() => { swapMode = true; swapFirst = null; SFX.play('powerup'); });
      break;
    case 'destroy':
      if (destroyMode) { destroyMode = false; return; }
      if (powers.destroy > 0) { powers.destroy--; destroyMode = true; SFX.play('click'); }
      else rewardAd(() => { destroyMode = true; SFX.play('powerup'); });
      break;
    case 'x2':
      if (powers.x2 > 0) { powers.x2--; x2Active = true; SFX.play('powerup'); }
      else rewardAd(() => { x2Active = true; SFX.play('powerup'); });
      break;
    case 'revive':
      if (revives < MAX_REV) rewardAd(() => {
        const gn = grid.length; const filled = [];
        for (let r = 0; r < gn; r++) for (let c = 0; c < gn; c++) if (grid[r][c]) filled.push({ r, c });
        filled.sort((a, b) => grid[a.r][a.c] - grid[b.r][b.c]);
        for (let i = 0; i < Math.min(3, filled.length); i++) { spawnParticles(filled[i].r, filled[i].c, '#ff3333', 10); grid[filled[i].r][filled[i].c] = 0; }
        revives++; gameState = 'playing'; gpStart(); SFX.play('powerup');
      });
      break;
    case 'menu':
      if (gameState === 'playing') { coins += Math.floor(score / 100); addToLB(); }
      saveAll(); gameState = 'menu'; gpStop(); tryMidAd();
      break;
    case 'shop': gameState = 'shop'; pauseTimer(); gpStop(); tryMidAd(); break;
    case 'back':
      if (gameState === 'shop') { gameState = 'playing'; resumeTimer(); gpStart(); }
      else gameState = 'menu';
      break;
    case 'leaderboard': gameState = 'leaderboard'; break;
    case 'achievements': gameState = 'achievements'; break;
    case 'sound': SFX.muted = !SFX.muted; saveAll(); break;
    case 'share': shareScore(); break;
    case 'tutnext': tutStep++; break;
    case 'tutdone': case 'tutskip': gameState = 'playing'; gpStart(); break;
    case 'adcoins': rewardAd(() => { coins += 30; SFX.play('coin'); saveAll(); }); break;
    case 'rate_yes': case 'rate_later':
      showRate = false; rateShown = true; coins += 200;
      SFX.play('star'); addFloat('+200 coins!', W / 2, H * 0.4, '#ffaa44');
      saveAll(); break;
  }
}

/* ===== EVENTS ===== */
CV.addEventListener('touchstart', (e) => {
  e.preventDefault(); SFX.resume();
  if (e.touches.length) { touchX = e.touches[0].clientX; touchY = e.touches[0].clientY; }
}, { passive: false });

CV.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (!e.changedTouches.length) return;
  const ex = e.changedTouches[0].clientX, ey = e.changedTouches[0].clientY;
  const dx = ex - touchX, dy = ey - touchY, dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 15) handleTap(ex, ey);
  else if (gameState === 'playing' && !swapMode && !destroyMode && !isAnim && !swapAnim && !gamePaused && !showRate && dist > 30) {
    if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 'right' : 'left');
    else move(dy > 0 ? 'down' : 'up');
    hintDir = null; saveAll();
  }
}, { passive: false });

let mouseDown = false, mx0 = 0, my0 = 0;
CV.addEventListener('mousedown', (e) => { mouseDown = true; mx0 = e.clientX; my0 = e.clientY; SFX.resume(); });
CV.addEventListener('mouseup', (e) => {
  if (!mouseDown) return; mouseDown = false;
  const dx = e.clientX - mx0, dy = e.clientY - my0, dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 15) handleTap(e.clientX, e.clientY);
  else if (gameState === 'playing' && !swapMode && !destroyMode && !isAnim && !swapAnim && !gamePaused && !showRate && dist > 30) {
    if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 'right' : 'left');
    else move(dy > 0 ? 'down' : 'up');
    hintDir = null; saveAll();
  }
});

document.addEventListener('keydown', (e) => {
  if (gameState !== 'playing' || isAnim || swapMode || destroyMode || swapAnim || gamePaused || showRate) return;
  let dir = null;
  switch (e.key) {
    case 'ArrowUp': case 'w': case 'W': dir = 'up'; break;
    case 'ArrowDown': case 's': case 'S': dir = 'down'; break;
    case 'ArrowLeft': case 'a': case 'A': dir = 'left'; break;
    case 'ArrowRight': case 'd': case 'D': dir = 'right'; break;
  }
  if (dir) { e.preventDefault(); move(dir); hintDir = null; saveAll(); }
});

document.addEventListener('visibilitychange', () => {
  if (document.hidden) { if (gameState === 'playing') { gpStop(); pauseTimer(); } }
  else { if (gameState === 'playing' && !gamePaused) { gpStart(); resumeTimer(); } }
});

window.addEventListener('resize', () => { resize(); initBg(); });

/* ===== INIT ===== */
SFX.init();
loadAll();
resize();
initBg();
checkDaily();
rateTimer = Date.now();
gameState = 'menu';
render();
</script>
</body>
  </html>
